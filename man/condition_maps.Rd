% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/future_walk.R
\name{future_cnd_map}
\alias{future_cnd_map}
\alias{future_cnd_imap}
\alias{future_cnd_map2}
\alias{future_cnd_pmap}
\alias{evaluate_fm_results}
\alias{signal_fm_conditions}
\title{Evaluate conditions signalled in \code{future_map} calls}
\usage{
future_cnd_map(.x, .f, ..., .progress = FALSE,
  .options = future_options())

future_cnd_imap(.x, .f, ..., .progress = FALSE,
  .options = future_options())

future_cnd_map2(.x, .y, .f, ..., .progress = FALSE,
  .options = future_options())

future_cnd_pmap(.l, .f, ..., .progress = FALSE,
  .options = future_options())

evaluate_fm_results(future_cnd_map_results, signalErrors = TRUE)

signal_fm_conditions(future_cnd_map_results, displayErrors = TRUE)
}
\arguments{
\item{.x}{A list or atomic vector.}

\item{.f}{A function, formula, or atomic vector.

If a \strong{function}, it is used as is.

If a \strong{formula}, e.g. \code{~ .x + 2}, it is converted to a function. There
are three ways to refer to the arguments:
\itemize{
\item For a single argument function, use \code{.}
\item For a two argument function, use \code{.x} and \code{.y}
\item For more arguments, use \code{..1}, \code{..2}, \code{..3} etc
}

This syntax allows you to create very compact anonymous functions.

If \strong{character vector}, \strong{numeric vector}, or \strong{list}, it
is converted to an extractor function. Character vectors index by name
and numeric vectors index by position; use a list to index by position
and name at different levels. Within a list, wrap strings in \code{\link[=get-attr]{get-attr()}}
to extract named attributes. If a component is not present, the value of
\code{.default} will be returned.}

\item{...}{Additional arguments passed on to \code{.f}.}

\item{.progress}{A logical, for whether or not to print a progress bar for
multiprocess, multisession, and multicore plans.}

\item{.options}{The \code{future} specific options to use with the workers. This must
be the result from a call to \code{\link[=future_options]{future_options()}}.}

\item{.y}{Vectors of the same length. A vector of length 1 will
be recycled.}

\item{.l}{A list of lists. The length of \code{.l} determines the
number of arguments that \code{.f} will be called with. List
names will be used if present.}

\item{future_cnd_map_results}{the output of one of the \code{future_cnd_map}-esque functions}

\item{signalErrors}{whether to signal errors or ignore them. You probably should not ignore errors.}

\item{displayErrors}{whether to display all the errors that happened in the call before signalling them. Helpful in seeing \emph{which} elements went wrong.}
}
\description{
These functions let you see the messages, warnings, and errors signalled in \code{future_map} calls. \cr \cr
Currently, the only conditions (here meaning: messages, warnings,
and errors) that are kept in non-sequential \code{future} plans are errors.
If you ran some complicated models on remote servers via \code{future_map},
and some of these models gave you important warnings, no functions outside of the \code{future_map} call would ever 'know' about them. \cr \cr
Similar to the \code{\link{future_walk}} series of functions, the \code{future_cnd_map} functions will collect and preserve these conditions, but instead of converting them to strings and getting rid of the returned values, these functions will keep the conditions as S3 condition objects as well as returning the actual values in \code{"value"}. \cr \cr
\code{signal_fm_conditions} takes the result of these functions, signals all the conditions for each element (displaying them grouped together sequentially for easier reading), and returns the value of the map. \code{evaluate_fm_results} does the same thing, but doesn't signal messages and warnings.
}
\details{
Like the \code{\link{future_walk}} series of functions, the \code{future_cnd_map} functions can be easily expanded with the \code{\link{future_map_maker}} function. You simply need to pick the \code{future_map} function you want to imitate and add the \code{asStrings = FALSE} argument.  For example, you could make a \code{future_cnd_map_chr} function as easily as: \code{future_cnd_map_chr <- future_map_maker(furrr::future_map_chr, asStrings = FALSE)}.
}
\examples{
future::plan(sequential) # other plans work fine as well
res <- future_cnd_map(1:3, function(i) {
  message(i)
  warning("Uh oh... ", i)
  if (i==2)
    warning("Additional warning!")
  if (i==3)
    stop("OH NO!")
  i + 3
})
\dontrun{signal_fm_conditions(res)}
}
\seealso{
\code{\link{future_map_maker}}
}
